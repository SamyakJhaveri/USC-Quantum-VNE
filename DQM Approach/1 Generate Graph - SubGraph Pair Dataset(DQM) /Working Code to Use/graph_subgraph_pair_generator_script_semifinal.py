"""
DQM Approach
Semi-Final Script. Works perfectly well but not used in the Final version of the Experiment.
Final Script is 'Working Code to Use' Folder with the other scripts and the conductor script. 


Code to generate Graph-Subgraph pairs and store them in a Dictionary 


References: 
- passing multiple arguments via the command-line: https://www.geeksforgeeks.org/executing-functions-with-multiple-arguments-at-a-terminal-in-python/


Features to Add:
- (done) A loop iterates i (nbumber of nodes in subgraph) over numbers from 3 to (n1 - 1) to generate graph-subgraph pairs, geenrate a name or that pair 
and use that name as the filename, and store that pair as a list of networkX graphs using pickle. 
- (done) turn this into a script
- (done) Could make a nested list of all the graph-subgraph pairs of a given main graph with n1 number of nodes. i.e. one pickle file that is essentially 
a list of all the graph-subgraph pairs that are possible for a certain n1 (number of nodes of main graph). So that for graphs with n1 = 5 to ???
 (My guess is to go till n1 = 20 for now and see how the algorithm performs)

"""

# Imports
import networkx as nx
import matplotlib.pyplot as plt
import random 
import pickle
import sys
import os 
import argparse


def generate_random_parent_graph(n, p):
        """
        Generating Random Graphs using the Erdos-Renyi Model as 
        provided by the NetworkX library

        Erdos-Renyi model of random graph generation is the 
        most typicall example used in many graph isomorphism papers

        Reference to Zick's Paper:
        ``Simple undirected N -vertex graphs were constructed 
        according to the Erd ̋os-R ́enyi G (n, p) model 
        with n = N and with the probability p of including each 
        edge equal to 0.5. Non-isomorphic pairs were generated 
        by creating two graphs as above and checking for 
        non-isomorphism using the MATLAB graphisomorphism() 
        function. Isomorphic pairs were generated by generating 
        a single graph then applying a random permutation to 
        arrive at the second graph.`

        Args: 
        n: number of nodes in parent graph 
        p: probability of there being an edge betwen two nodes in the graph

        Returns:
        G1: Parent Graph generated using Erdos-Renyi Model
        """

        G1 = nx.fast_gnp_random_graph(n, p, seed = None, directed = False)

        # Drawing Graph G1
        # pos = nx.spring_layout(G1)
        # Commented for now to precent i tfrom interrupting the code to geenrate the graph-subgrpah pairs using the for loop
        # nx.draw(G1, 
        #        pos = pos,
        #        with_labels = True, 
        #        node_color = "tab:blue")
        # plt.show()  
        return G1


def generate_child_subgraph(G1, n):
        """
        Generating the SubGraph from the Parent graph
        Args:
                G1: Parent Graph
                n: number of nodes in SubGraph
        Returns:
                G2: Child SubGraph
        """

        n1 = G1.number_of_nodes()

        # Graph.subgraph(nodes) # option 1
        # G2 = G1.subgraph(random.sample(list(G1.nodes), n2)) # option 2
        """ This works for now. Try looking for a better way to generate SubGraphs """
        G2 = G1.subgraph(range((n1 - n), G1.order())) # option 3

        # Drawing the Sub Graph
        # Commented for now to precent i tfrom interrupting the code to geenrate the graph-subgrpah pairs using the for loop
        # pos = nx.spring_layout(G2)
        # nx.draw(G2, 
        #        pos = pos,
        #        with_labels = True, 
        #        node_color = "tab:red")
        # plt.show()
        return G2


# def save_G1_G2_pair(G1_G2_pair_list, filename):
def save_G1_G2_pair(G1_G2_pair_list):
        """ 
        Function to Save one Graph - SubGraph Pair 
        
        Args:
        - G1_G2_pair_list: Pair of Graph and its SubGraph in List form, 
                        (first element of list is Parent Graph, second element of list is SubGraph)
        - filename: Filename to be used to store the Graph-Subgraph pair as pickle
        """

        n1 = G1.number_of_nodes()
        n2 = G2.number_of_nodes()
    
        filename = "G1(" + str(n1) + ")_G2(" + str(n2) + ")_iso.pickle"

        try:
                with open(filename, "wb") as f:
                        pickle.dump(G1_G2_pair_list, f, protocol = pickle.HIGHEST_PROTOCOL)
                        print("Stored Graph-SubGraph pair as :{}.".format(filename))
        except Exception as ex:
                print("Error during pickling object (Possibly unsupported).", ex)


def save_G1_G2_pair_dict(filename, G1_G2_pair_dict):
        """ 
        Function to Save the Graph - SubGraph Pair Dictionary
    
        Args:
        - G1_G2_pair_dict: All the Pairs of Graph and its SubGraph in List form, 
                        stored inside a dictionary 
                        (first element of list is Parent Graph, second element of list is SubGraph)
        """

        try:
                with open(filename, "wb") as f:
                        pickle.dump(G1_G2_pair_dict, f, protocol = pickle.HIGHEST_PROTOCOL)
                        print("Stored Graph-SubGraph pair Dictionary Dataset.")
        except Exception as ex:
                print("Error during pickling object (Possibly unsupported).", ex)


def load_G1_G2_pair_from_file(filename):
    """ 
    Function to Load a Graph - SubGraph Pair from a given filename
    
    Args:
    - filename: Filename of the Graph-Subgraph pickle to be loaded from storage 
    """

    try: 
        with open(filename, "rb") as f:
                print("Loaded {} pickle file from storage.".format(filename))
                return pickle.load(f)
    except Exception as ex:
            print("Error during unpickling object (Possible unsupported).", ex)


def load_G1_G2_pair_dictionary(filename):
    """ 
    Function to Load the Graph - SubGraph Pair Dictionary Dataset 
    
    Args:
    - filename: Filename of the Graph-Subgraph Dictionary Dataset pickle to be loaded from storage 
    """

    try: 
        with open(filename, "rb") as f:
                print("Loaded {} pickle file from storage.".format(filename))
                return pickle.load(f)
    except Exception as ex:
            print("Error during unpickling object (Possible unsupported).", ex)


def load_G1_G2_pair_from_dictionary(key):
        """ 
        Function to Load a Graph - SubGraph Pair from the Dictionary Dataset 
    
        Args:
        - key: key of the Graph-Subgraph pair to be loaded from the Graph-Subgraph Dictionary Dataset
        """

        try: 
                with open(filename, "rb") as f:
                        print("Loaded {} pickle file from storage.".format(filename))
                        return pickle.load(f)
        except Exception as ex:
                print("Error during unpickling object (Possible unsupported).", ex)


def plot_graphs(G1_G2_pair_list):
    """
    Plot graphs of two circuits 

    Args:
        - G1_G2_pair_list: Pair of Graph and its SubGraph in List form
    """

    G1 = G1_G2_pair_list[0]
    G2 = G1_G2_pair_list[1]
    
    f, axes = plt.subplots(1, 2, figsize = [10, 4.5])
    nx.draw(G1, with_labels = True, ax = axes[0], node_color = "tab:blue")
    nx.draw(G2, with_labels = True, ax = axes[1], node_color = "tab:red")
    plt.show()


if __name__ == "__main__":
        """
        Version of the Code that hard-codes values like n1, n2 and p in the 'main' function of the script
        
        # Defining number of nodes and the probability of there being an edge
        # two nodes in the Larger/Main/Parent graph
        n1 = 10 # number of nodes in Parent Graph
        p = 0.5 # probability of edge creation between two nodes
        n2 = 6 # number of nodes in the subgraph
        """

        """
        Version of the code that takes values of n1, and n2 as command line arguments 
        and p is always kept as 0.5
        

        print("Enter the "
        "\n Number of nodes in Parent Graph (G1) as the first command-line argument (n1), and"
        "\n Number of nodes in SubGraph (G2) as the second command-line arcgument(n2)")
        # p = 0.5
        # n1 = int(sys.argv[1])
        # n2 = int(sys.argv[2])

        # p is chosen to be 0.5 as per Zick's paper. 
        # G1 = generate_random_parent_graph(n1, p)
        # G2 = generate_child_subgraph(G1, n2) 

        # saving the Graph-SubGraph Pair
        # save_G1_G2_pair([G1, G2], filename)
        """

        """
        Version of the code that generates Graph-SubGraph pair dictionary 
        """
        dataset_filepath = "/Users/samyakjhaveri/Desktop/Drive Folder/Research/USC Internship Quantum Virtual Network Embedding Project 2022/DQM Approach/Dataset(DQM)/G1_G2_PAIR_DICTIONARY_DATASET.pickle"
        
        """
        print("Enter the Number of nodes in Parent Graph (G1) as a command-line argument (n1)")
        n1 = int(sys.argv[1])

        print("Default p (probability of there being an edge between two nodes) is 0.5 i.e. 50%")
        # p is chosen to be 0.5 as per Zick's paper.  
        p = 0.5
        n2 = n1 - 1 # if n1 = 20, then n2 = 20 - 1 = 19, n2 is number of nodes possible in SubGraph
        G1_G2_pair_dict = {} # dictionary to keep all the graph-subgraph pairs in one place. 
        # Will store only this one dictinoary instead of storing every graph-subgraph pair in 
        # a separate file that has to be stored and retreived everytime a new pair is 
        # generated which makes the whole process computationally heavy

        key = ""

        for i in range(5, n1 + 1):
                # This loop iterates over the number of nodes G can have.
                # range() is written this way as it only meaningful to have a G with at least 5 nodes
                # and the upper limit of the range is chosen as `n1+1` because range() with upper limit 
                # as `n1` does not include the last number (i.e. `n1` number of nodes)
                G1 = generate_random_parent_graph(i, p)
                for j in range(3, n2 + 1):
                        # This loop iterates over the number of nodes G2 can have. 
                        # range() is written this way because it is only meaningful to start having subgraphs 
                        # that at least have 3 nodes and make a triangle.
                        # the reason behind chosing `n2 + 1` as the upper limit of the range() is the same as 
                        # that for the above loop for G1. 
                        G2 = generate_child_subgraph(G1, j)
                        key = "G1(" + str(i) + ")_G2(" + str(j) + ")_iso" # G1(20)_G2(19)
                        G1_G2_pair_dict[key] = [G1, G2]
        
        
        # Saving the Graph-SubGraph Pair Dataset in the designated directory
        save_G1_G2_pair_dict(dataset_filepath, G1_G2_pair_dict)
        print("\n DONE!")
        """
        
        """ Retreiving the G-SG Pair Dataset from the Directory """
        # Commented out because this script is only for saving the graph pairs generated
        
        G1_G2_pair_dict_loaded = load_G1_G2_pair_dictionary(dataset_filepath)
        print("Graph-SubGraph Pair Dictionary Dataset:")
        print(G1_G2_pair_dict_loaded)
        print("The Dataset has {} Graph-SubGraph Pairs.".format(len(G1_G2_pair_dict_loaded)))

        parser = argparse.ArgumentParser()
        parser.add_argument("--n1")
        parser.add_argument("--n2")
        args = parser.parse_args()

        # whatever key you want with the format: G1(<n1>)_G2(<n2>)_iso
        key = "G1(" + args.n1 + ")_G2(" + args.n2 + ")_iso"  # "G1(20)_G2(19)_iso"
        G1_G2_pair_list = G1_G2_pair_dict_loaded[key]
        print("Graph - SubGraph Pair:{}".format(G1_G2_pair_list))
        plot_graphs(G1_G2_pair_list)
        